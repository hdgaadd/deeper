# basics

- **删除元素**

  - 删除元素使用iterator.remove()

    ```java
    Iterator<Integer> iterator = list.iterator();
            while(iterator.hasNext()){ 
                int ans=iterator.next();             // 每一次next()得到一个元素，并且该next()操作会把指针向后移动，下一次iterator.next()得到的是下一个元素
                if(ans==2)
                    iterator.remove();
    }
    ```

  - 使用for循环

    遍历集合时不要使用for循环删除元素，有两个相同的想删除的元素时，for循环只会删除掉一个

    ```java
    for(int i=0;i<list.size();i++){          
       if(list.get(i)==2)
          list.remove(i);}
    ```

  - 使用foreach不能删除元素，会报错ConcurrentModificationException        `Modification修改[ˌmɒdɪfɪˈkeɪʃn]`

    因为每次foreach执行都会判断`modCount数组修改的次数`是否和`预期修改次数exceptedModCount`一致，因为list.remove()修改了数组，导致不一致，不一致底层直接抛出ConcurrentModificationException

    ```java
    for(int i:list){
    	if(i==1){
    		list.remove(1);break;     // 否则remove()使用break则不会抛出异常
    	}
    }
    ```

- **Object的方法**

  - equals()、toString()

  - notify()、notfyAll()、wait()

  - getClass()

  - clone()浅拷贝

  - finalize

    完成[ˈfaɪnəlaɪz] 

- **java基本数据类型的长度**

  - short

    2

  - int

    4

  - long

    8

  - byte

    1

  - boolean

    1

  - char

    2

  - float

    4

  - double

    8

- **常见的异常**

  - ClassNotFoundException

  - FileNotFoundException

  - NullPointerException

  - ClassCastException

  - IndexOutOfBoundException

    [baʊnd]限制

- **多态是什么**

  多态总的来说是对做什么和怎么做的分离

  - 子类实现接口，有多少个子类实现，该接口就有多少种**表现形式**

- **生产者消费者**

  - 使用ArrayBlockingQueue实现，队列满了，生产线程就进入阻塞，队列空了，消费线程就进入阻塞；而每一次消费产品就去唤醒生产线程，每一次生产产品就去唤醒消费线程

- **LinkedHashMap、PriorityQueue**

- **maven生命周期**

  clean生命周期、default生命周期、site生命周期

- **maven冲突**

  项目依赖的jar包都有自己隐式的依赖jar包，版本不同的隐式的依赖jar包被引入到maven后会造成maven冲突

- **ArrayList扩容复杂度**

  O(n)

- **http + https**

  - https要申请证书，http和https使用的端口不同，其中https采用非对称加密传输、身份认证的网络协议，相比http更加安全
  - http是无状态协议，而https是有状态协议
  - http的请求是明文传送的，https的请求是密文传送的

- **Array的优点**

  可设置固定长度的数组，缺点：数组长度过长造成内存浪费，过短造成数组越界

- **List的优点**

  可自增长的数组，不会出现数组越界，缺点：某些List类型，如ArrayList、LinkedList是线程不安全的集合

- **LinkedList线程不安全原因**

  没有synchronized，如果有两个线程同时操作addFist，因为addFirst需要把新添加的元素设为头节点first，当一个线程把a元素设为first后，还没有与旧链表建立联系，另一个线程把b元素设为了first，造成了数据覆盖，最后两个线程执行完了只添加了一个元素

- **通过反射或new创建对象**

  - new创建对象：作为静态编译，在编译阶段就使用ClassLoader把.class文件加载到内存；初始化static变量、static代码块；运行期再初始化普通变量，执行构造方法创建对象
  - 反射创建对象：作为动态编译，在编译阶段不会使用ClassLoader把.class文件加载到内存；初始化static变量、static代码块；在运行期使用Class.forName()才会执行以上      //故在运行期反射比new多做了以上，相比之下比new慢再使用newInstance()才会执行初始化普通变量，执行构造方法创建对象

- **反射三种机制**

  Class.ForName()、类字面常量、new然后getClass()

- **拼接效率+和append**
  StringBuilder的append()效率最高

- **跨域**
  what：当请求url的协议、域名、端口与当前页面的url不同即为跨域
  why：浏览器约定的同源策略，当浏览器跳转到某个url时，如果是跨越的url，就不会跳转
  sloved：可以在Controller类添加@CrossOrigin      Origin起源[ˈɒrɪdʒɪn]

- **DDOS攻击**

  > Distribution Denial of service分布式拒绝服务攻击

  - 建立在三次握手基础上，客户端向服务端发送SYN联机**请求后断线**，服务端发送的SYN+ACK报文在没有客户端应答就会在一段时间内**继续重试**

    攻击者制造了无数这种请求，导致服务端无数次发送报文、重试，服务端资源被耗光，不能给正常用户提供服务

- **动态代理和静态代理的区别**

  - 静态代理
    **手动创建**一个拥有被代理类所有方法的代理类，在主程序创建代理对象，并把被代理对象作为参数传给代理对象，调用代理类的方法，就会执行我们需要的方法，接着执行保存的代理对象的同名方法

    ```java
    public class ProxyTest{
      Test test;
      public ProxyTest(Test test){
         this.test=test;}
      public void method(){
         sout("我们的方法");
         test.method();//被代理对象的方法
      }
    }
    ```
    
  - 动态代理

    **运行**时**动态生成**类的**字节码**文件

- **JDK与CGLIB的区别**

  - JDK只能代理实现接口的类，CGLIB没有此限制

  - 原理不同：

    JDK是动态生成代理类的字节码文件跳转到invoke()，而CGLIB是**修改字节码**文件，生成代理类的**子类**，覆盖代理类的方法

    该修改应该是`Test t = new Test(); -> Test t = new TestSon();`

- **Spring AOP与AspectJ AOP的区别**

  JDK、CGLIB是**运行**时增强，AspectJ是**编译**时增强，故AspectJ AOP速度更快

- **JDK和CGLIB哪个快**

  > 两者的生命周期可以分为创建对象阶段、实际运行阶段

  - 在**实际运行**阶段，CGLIB性能比JDK运行性能**更高**

  - 在**创建对象**阶段，基于两者的原理，CGLIB花费在**创建对象**的时间要比JDK多

    JDK**只需**创建代理类的字节码，**而**CGLIB既要修改源代码的字节码文件，又要生成代理类的子类的字节码文件

  - 故若是对于在需大量创建对象的场景，JDK比CGLIB效率更高，反之CGLIB效率更高

- **jdk8新特性**

  - lambda表达式

  - Streams.API函数式编程：针对Collections类型对象的增强，让操作这些对象需要书写的代码更简洁、易懂

    ```java
    ArrayList<Integer> list = new ArrayList<Integer>(){{add(1);add(2);add(3);}};
    for(int i : list){
        System.out.println(i);
    }
    相当于
    integers.forEach(i -> {
    	System.out.println(i);
    });
    有条件判断需要加{}
    list.forEach(i -> {    
        if(i == 1) { System.out.println("hhhhhhhh"); }
    });
    
    ```

  - 8之后接口可以有static方法，8之后接口可以有普通成员变量，而之前只能有public static final

- **error和execuption区别**

  - execuption指程序运行期或非运行期可预料到也可处理的异常
  - error指程序无法预料也无法处理的的错误

- 子类重写的方法抛出的异常不能大于父类


- **重写一个对象为什么要重写hashCode()和equals()**
  是为了让诸如hashmap这样对equals()、hashCode()有要求的类可以正常运行，

- 例如一个对象作为一个键，他们的equals()为true即相等，那hashCode()就必须相同，这就要求equals()、hashCode()两者必须有关联，即重写一个对象必须要重写hashCode()和equals()


- mysql怎么看是否有索引


- **回调函数**

  把自定义的**函数方法对象**，调用他的invoke()，让其作为参数传递给该方法所在的**对象实例**，**委托**该实例来执行该函数方法

  通过回调函数，可以实现调用**n个类**的相同方法，**提高**系统可扩展性可维护性

  **function**：**异步调用**的作用

  - 通过回调函数，调用**n个类**的相同方法

    与直接调用的效率差可以**忽略不计**，提高代码的简洁度，**提高**系统可扩展性可维护性

  - 通过回调函数，调用n个方法

    一般不会这样使用

  - 通过回调函数，调用n次方法

    调用n次，使用直接调用也可以

- **缺省==默认**

- ```java
  //外部类不可以使用private、protected，只能使用public或默认，而内部类可以
  //其中继承一个类继承一个内部类，则该内部类的构造方法必须实例化主类
  public class A {    //No enclosing instance of type 'Offer.a.A' is in scope没有封闭的A实例在范围内
      protected static class C{
          int a=1;
          public C(){
              new A();
          }
      }
  
  }
  ```
  
- **Streams.API**

  Streams.API作为jdk8添加的新功能可以方便快捷地对数组、集合进行操作和计算

  ```java
  int [] array = {7, 8, 4, 5, 1, 6, 4, 1, 9};
  int sum1 = 0;
  for (int i = 0; i < array.length; i++) 
      if(array[i]%2 != 0) 
          sum1 += array[i];
  //Streams.API
  int sum2 = Arrays.stream(array)
                  .filter(i -> i%2 != 0)
                  .sum();
  ```

- **面向对象5大基本原则**

  - 单一职责原则

    尽量使一个类实现一个功能模块，而不是把所有的功能模块都堆积在同一个类

  - 开闭原则

    成员变量、函数对于扩展应该是开放的，而对于修改是封闭的，有利于软件迭代、维护时不会因修改而破坏原系统

    达到通过扩展实现软件变化，而不是通过修改

  - 接口隔离原则

    每一个接口应该设计完善，不把**不同功能属性**的接口合为同一个接口；每一个类不应该实现他不需要的接口
    
  - 依赖倒置原则
    
    原本是高层组件拥有类中不可缺少的底层组件，故高层组件依赖于底层组件
    
    而依赖倒置原则实现了1.高层组件不依赖于底层组件，而依赖于其抽象2.底层组件依赖于其抽象
  
  - 里式替换原则
  
- **哈希冲突的解决方法**

  - 拉链法，也叫链地址法
  - **再散列法**：再次计算下标直至不冲突、开发地址法
  - 开放地址法
  - 建立一个公共溢出区

- **哈希函数**

  - 指将键智能映射为元素存储下标的函数

- **链表倒置方法**

  - 栈

  - 头插法

      jdk7之所以链表反转是因为头插法

- **String和StringBuffer和StringBuilder区别**

  - String类型的数据是**不可变的**，而其他两者可以

  - StringBuffer的方法都使用**synchronized**故线程安全，String是**final**的故线程安全，而StringBuilder线程不安全

  - **性能**StringBuilder > StringBuffer > String，因为String需要不断创建常量池对象，StringBuffer使用synchronized消耗性能

  - StringBuffer有设置一个char**缓存数组**，故StringBuffer相比其他更适合操作大量数据
    
    private transient char[] toStringCache;
    
  - ALLINALL：操作少量数据使用String，单线程操作大量数据使用StringBuilder，多线程使用StringBuffer 

- **String类的特性**

  - final不可继承，保证安全
  - 内存空间是常量池的复制

- **GET和POST的区别**

  - 两者本质都是**TCP请求**，只是浏览器对TCP请求进行了**分类**，分为GET和POST

    GET一般用来获取数据，POST用来提交数据

  - GET请求的参数一般位于URL中，即请求行；POST请求的参数位于请求体中

  - GET提交的数据会保存在浏览器中，而POST不会

  - **knowledge**

    HTTP请求由请求头、请求体、请求行组成

- **cookie和session**


  - cookie保存在客户端：登录日期

  - session保存在服务端：验证码

  - session其实的id是一个cookie保存在客户端，客户端发送该cookie形式的session id在服务端找到对应的session值

- **TCP、UDP区别**

  - TCP面向连接协议，UDP是面向无连接的用户数据报协议
  - TCP三次握手保证数据传输可靠性，UDP可能丢包
  - TCP保证数据顺序，UDP不保证
  
- **为什么分为内核态和用户态**

  如果没有区分，则用户可以随意访问**硬件资源**，若把某些内容写入了不该写的地方，容易造成**系统崩溃**

  有效保护硬件资源的安全

- **应用场景**

- 动态规划

  爬楼梯、斐波那契数列

  适合对n个特定操作，要达到最终目的，共有多少种方案的问题

  - 观察者模式

    公众号发布文章

    某个变量的改变，要**通知多个**对象时

  - 策略模式

    适合对**if-else**进行可扩展性设计，因为if-else里的处理逻辑大致一致

    把if-else**封装**成类的方法，if-else括号里的参数作为**选择条件**，以选择某个类的方法

  - 迭代器与组合模式

    使树形结构类型的集合，可以使用**同一个方法**进行遍历

  - 工厂方法模式

    该模式是把实现推迟到子类，故适合对返回结果**确定**，具体实现过程**不确定**的场景

  - 单例模式

    适合对某一对象具有**唯一性约束**的场景，如Spring框架的singleton bean

- **一次会话是什么**

  一次会话代表的是一个session对象

  具体来说，是服务端保存的session**过期**，或者是客户端保存的cookie**丢失**

  一般是**浏览器**打开后关闭则cookie丢失，故本次会话结束
  
- **两个栈怎么实现队列**

  把一个栈作为**存储数据**的栈，另一个作为**抛出数据**的栈，每次**添加**数据往第一个栈添加，每次**抛出**数据，若第二个栈不为空则直接抛出第二个栈的数据，若第二个栈为空则从第一个栈获取数据填充后抛出
  
- **关于final**

  - **final修饰类与方法**

    - final修饰的类为最终类，不能被**继承**

      如String

    - final修饰的类可以被**继承、访问、重载**，但不能被**重写**

  - **final修饰的类可以被代理吗**

    - 若使用**CGLIB**动态代理，底层实现是生产代理类的子类，而final不能被**继承**，故不能
    - 若是使用**JDK**动态代理，只要该final类**实现接口**，即可被代理
  
- **关于继承的static**

  - 子类可以**继承、访问、重载**，但不能**重写**

  - 父类的private才不能被**访问**

    private子类有**继承**，但是不能访问

- **group执行顺序**

  WHERE后GROUP BY，后HAVING
  
- **interface接口和abstract接口的作用**

  - interface
    - 提供了一套**规范**，实现他的子类必须**遵守**这套规范，且间接对这些子类进行了**分类**
    - 提高了**可扩展性**，若要给属于**某一类**的对象，**统一都添加**新方法，只需要修改接口，则子类都必须添加该新方法
  - abstract
    - 若对方法的返回值与类型**确定**，但具有执行逻辑**不确定**，可以使用abstract，把具体实现**延迟到子类**
    - 提高了**可扩展性**，让代码具有可继承性
  
- **重载与重写**

  - 重载**不要求**返回值，要求方法名相同、参数类型或个数不同
  - 重写要求返回值、方法名、方法参数一致

- **子类可以重写、重载父类的构造方法吗**

  - **不可以重写**，重写要求返回值相同，而构造方法**没有返回值**，默认构造方法是不可被重写的
  - **可以重载**

- **线程同步的方式**

  - synchronized对象锁、类锁
  - 对线程使用wati()、notify()
  - ReentrantLock
  - ThreadLocal
  - volatile
  - AtomicInteger

- **接口与抽象类的区别**

  - **区别**

    > JDK8之后，抽象类abstract和接口类interface的具体功能，总体没有什么区别

    - **普通接口方法**只能由public abstract、default、static修饰；**抽象接口**方法可以由所有修饰符修饰，除了final

      普通接口、抽象接口方法都不能使用**final**修饰

    - **普通接口变量**只能由public static final修饰；**抽象接口变量**可以由**所有**修饰符修饰

    - abstract是is-a继承关系，interface是like-a**组合**关系

    - 接口不能有构造方法，抽象类可以有**构造方法**

    - abstract class A{}、interface AA{},abstract有class

    - 一个普通类只能继承一个abstract类，而一个普通类可以实现多个interface接口

    - 类不能多继承类，接口可以多继承接口类

      ```java
      interface People {
       default void eat(){
        System.out.println("人吃饭");
       }
      }
      interface Man {
       default void eat(){
        System.out.println("男人吃饭");
       }
      }
      interface Boy extends Man, People {
       @Override
       default void eat() {                  //但必须重写父类的方法，不然编译器不知覆盖哪个父类的eat()
        System.out.println("男孩吃饭");
       }
      }
      ```

      > 继承类或接口类都一样，一个接着继承一个的话，子类.父类方法,该方法使用最接近子类的父类的方法

  - **联系**

    - 接口和抽象类接口都可以有成员变量
    - 接口和抽象类接口都**不能实例化**：接口类 is abstract; cannot be instantiated
  
- **有连接协议和无连接区别**

  有连接**需要**双方建立连接后，才可发送通信数据

  而无连接协议**无需**建立连接，发送方就可发送通信数据，且不管接收方是否接收

# lock

- **for循环下的synchronized**

  for循环下的synchronized可用，执行一个for循环后可能就失去资源锁而进入等待状态，输出与for循环顺序不一致

  而synchonized下的for循环，执行顺序是按for循环的顺序

- **volatile有什么用**

  - 保证数据的**可见性**，不保证数据的**原子性**

    线程在操作volatile变量时，都会去获取内存中**最新**的值，即可见性
    
  - 与static区别

    static是所有实例**共享**同一变量，而不是可见性

- **可重入锁**

  - 线程获取锁资源后，下一步进入**相同锁资源**的同步代码块，不需要再获取锁

- **锁升级**

  - 目的：对**synchronized**进行性能优化
  
    synchronized阻塞、唤醒线程，需要切换CPU状态来完成，耗费太多时间
  
  - 升级步骤：
    - 无锁
  
    - 当有线程访问锁时，升级为**偏向锁**
    
    - 当有线程竞争锁时，升级为**轻量级锁**
    
    - 当自旋10次失败时，升级为**重量级锁**
    
      指循环等待10次
  
- **锁消除**

  当一段程序加上同步锁后，若JVM**检测不到**任何线程会竞争该锁资源，则会进行锁消除，忽略该同步代码块

- **锁粗化**

  若一系列连续的操作都是对**同一个**锁资源进行请求，则JVM会把锁的范围**粗化**到这一系列连续操作的外部，这样则只需要获取**一次**锁资源即可

- **分段锁**

  - JDK7

    对Entry数组级别**进行分段**，一个Entry即一条链表是一个段，每段都设有一个**segment分段锁**[ˈseɡmənt]

    多线程访问不同分段的数据，则不会产生锁竞争，提高并发效率
    
    Segment继承ReentrantLock
    
  - JDK8

    对**元素级别加锁**，若该位置不存在元素，则使用CAS操作来添加值，若该位置存在元素，则使用synchronized对该位置的**头节点**加锁

    CAS操作的比较和替换是**原子操作**，这样则不怕多线程干扰

- **HashTable和ConcurrentHashMap效率对比**

  HashTable锁住的是整个链表，而ConcurrentHashMap锁住的是一个分段，后者效率更高

- **Java有什么锁**

  - synchronized有类锁、对象锁
  - ReentrantLock有公平锁、非公平锁
  - Segment分段锁[ˈseɡmənt]
  - 锁升级：偏向锁、轻量级锁、重量级锁
  - 按两类区别：乐观锁、悲观锁



# thread

- **进程通信**

  - 任何进程的成员变量在**另一个进程中看不到**，所以需要有缓存区提供拷贝保存和读取数据
  
    管道、消息队列、信号量semophore、信号signal、共享内存、socket
  
- **线程是怎么通信的**

  - notifyAll、notify、signal、volatile:被volatile修饰的变量一个线程更新了该值，会通过主内存这条消息总线告诉所有使用该变量的线程

- **进程线程**

  - 进程是资源分配的最小单位，线程是CPU调度的最小单位
  
- **java线程状态或线程的生命周期**

  - 初始状态        
  
    创建了线程对象还没有调用start()       
  
  - 就绪或运行状态     
  
    执行了start()可能运行可能在等待CPU资源
  
  - 阻塞状态       
  
    一直没有获得锁
  
  - 等待状态
  
    等待其他线程的通知唤醒
  
  - 超时状态       
  
  - 终止状态   
  
- **ThreadLocal**

  - 多线程共享**同一个变量**环境下，使用ThreadLocal来保存属于该线程的当前变量值
  
    ThreadLocal里的ThreadLocalMap的key为线程对象，value为线程的变量，确保了每个线程的变量只属于本线程，不会被其他线程共享、影响到
  
    - 线程不安全：
  
      ```java
      public class no_security {
          public static void main(String[] args) {
              ExecutorService es = Executors.newFixedThreadPool(20);
              for (int i = 0; i < 20; i++) {
                  int number = i;
                  es.execute(() -> System.out.println(number + ":" + new intUtil().addTen(number)));
              }
          }
          static class intUtil {
              public static int num = 0; // 关键点在于num是共享变量，下一个线程修改该值，上一个线程的获取该值也会改变
      
              public int addTen(int number) { // num起到保存number的作用
                  num = number;
      
                  try { // 休息1秒，让下一个线程可以提前运行
                      TimeUnit.SECONDS.sleep(1);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
                  return num + 10;
              }
          }
      }
      ```
      
    - 线程安全：
    
      ```java
      public class security {
        public static void main(String[] args) {
              ExecutorService es = Executors.newFixedThreadPool(20);
            for (int i = 0; i < 20; i++) {
                  int number = i;
                  es.execute(() -> System.out.println(number + ":" + new intUtil().addTen(number)));
              }
          }
          static class intUtil {
              public static int num = 0;
              
              public static ThreadLocal<Integer> threadLocal = new ThreadLocal<>(); // 使用threadLocal保存线程保存的当前共享变量num
      
              public static int addTen(int number) {
                  num = number;
                  threadLocal.set(num);
                  
                  try { // 休息1秒
                      TimeUnit.SECONDS.sleep(1);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
                  return threadLocal.get() + 10;
              }
          }
      }
      ```
    
  - 用来提供线程内部的局部变量
  
    eg：使用单例模式访问数据库连接对象Connection，因为只能同时由一个线程访问，故造成服务器的性能降低，可以使用ThreadLocal提供线程内部的局部变量实现其他线程的访问，确保了线程安全的情况下性能也得到了提升
  
    **那怎么提供，选择题提到threadlocal不共享本地变量**？
  
- **main方法执行完，其他线程会退出吗**

  - 线程分为守护、非守护线程，JVM的退出**不关心守护线程**是否结束
  - 若main方法执行完，程序存在非守护线程，则等待非守护线程执行完
  - 若main方法执行完，程序存在守护线程，仍然关闭
  
- **进程分类**

  - 孤儿进程

    **父进程退出**，而其子进程**仍在运行**，这些线程称为孤儿进程

    强制关闭程序，容易产生孤儿进程

  - 僵尸进程

    **子进程退出**，父进程没有调用wait或waitpid**回收**子进程的状态信息，则子进程的**进程描述符**会继续保留在系统中，该进程称为僵尸进程

- **线程分类**

  - 粗分类：

    - 主线程

      main()

    - 子线程

      非主线程即子线程

  - 细分类：

    - 守护线程

      为主程序**提供服务**的线程，如GC线程

      也称为**后台**线程

    - 非守护线程
    
      一般是自己创建的线程，可以通过**setDaemo(true)**设置守护或非守护线程
      
      也称为**用户**线程、**前台**线程

- **线程里有什么**

  - 栈空间
  - 程序计数器
  
- **AQS原理**

  > AbstractQueuedSynchronizer抽象队列同步器，为Java构建锁，对线程进行阻塞、唤醒的**基本框架**

  - 原理是内部拥有一个双向的同步队列，若线程获取锁资源失败，AQS则会**阻塞**当前线程，将当前线程和相关信息构造一个**Node**，将其加入同步队列的尾部，当锁资源释放时，则为队列头节点的线程**解除阻塞**


# internet

- **HTTPS的加密**

  - 内容传输使用对称加密，**证书验证**使用非对称加密

    非对称加密效率低，不能使用在内容传输上

- **HTTPS连接过程**

  - 证书验证阶段：

    - 浏览器发送HTTPS请求
    
    - 服务端返回HTTPS**证书**
    
    - 客户端验证证书
    
      证书使用CA机构的**非对称加密技术**进行加密，若该证书附带的公钥能使用该技术进行解密成**明文**，则证书合法
    
  - 传输阶段：
    
    - 合法则生成**随机数**，使用证书上的**公钥**对随机数进行加密，传输到服务端
    
      该随机数**不是传输内容**，而是给服务端构造加密算法，本次连接传输的内容只有服务端发送的
    
      - 服务端通过证书的**私钥**解密随机数，再根据**随机数构造**对称加密算法，对返回内容进行加密，后传输
    
      - 客户端根据之前生成的随机数对返回内容进行解密
  
- **HTTPS为什么安全**

  - 证书验证

    服务端返回给客户端的证书，需要经过**CA机构认证**，才能算合法证书，若不合法证书则浏览器会告警

    则**避免了访问**非法服务端

  - 加密技术

    即使中间人拦截了客户端发送的随机数，需要获取服务端的私钥才能解密

    即使中加入拦截了服务端发送的返回内容，需要获取客户端的随机数才能解密

# JVM

- **类加载器作用**

  - 把.class文件加载到Java虚拟机的内存中

- **类加载器类型**

  > 以下是从父类到子类的顺序

  - Bootstrap ClassLoader     `启动类加载器`
  - Extension ClassLoader   `[ɪkˈstenʃn]扩展类加载器`
  - App ClassLoader     `应用程序类加载器`，加载我们应用程序范围内的.class
  - Custom ClassLoader    `[ˈkʌstəm]自定义类加载器`

- **双亲委派机制**

  - 一个**子类**类加载器把加载.class文件的任务，委托给他的**上级**类加载器，如果上级类加载器认为该任务不是他**工作范围**，再把该任务重新交付给子类类加载器，让子类类加载器**自己去执行**

  - **function**

    防止同一个.class文件不会被**加载多次**：因为以上双亲委派机制内容，一个.class文件只会被父类**或**子类其中一个类加载器加载

- **类加载机制**

  总结来说，即时编译器把.java文件编译为JVM可识别的**.class文件**，再把.class文件通过类加载器加载进内存，把**.class里的数据**进行解析、转换为JVM**可识别**的类型数据

- **JVM内存布局**

  ![JVM Data Areas](./images/JVM Data Areas.png)

  - 程序计数器：保存线程当前执行的指令与下一条指令
  - 本地方法栈：作为native方法变量的存储空间
  - 方法区：保存类结构信息、类成员变量即static变量 	 
  - 虚拟机栈：保存局部变量
  - 堆：保存成员变量

- **变量名与值的存储位置**

  > 变量名 - 变量值
  >
  > 引用变量 - 内存空间
  >
  > 不同的声明位置具有不同的存储位置

  - 成员变量

    变量名存储在**堆**，变量值无论是基本还是引用**都**存储在堆

  - 类变量

    变量名存储在**方法区**，变量值若是基本则存储在**方法区**，若是引用则存储在**堆**

  - 局部变量

    变量名存储在**虚拟机栈**，变量值若是基本则存储在**栈**，若是引用则存储在**堆**

- **深拷贝与浅拷贝**

  - 浅拷贝 

    把新拷贝出来的对象的**成员变量**指向，设置与被拷贝的成员变量的**内存空间地址**一致

  - 深拷贝

    新拷贝出来的对象的**成员变量**值与被拷贝对象的成员变量值一致，但新拷贝出来的成员变量的**指针**与内存空间是**新创建**出来的

- **堆内存划分**

  - 新生代

    存储new出来的对象没有引用指向后，被GC回收，**即对象存活时间短的**

  - 老年代

    存储经历多次GC都没有被回收，**即对象存活一定时间后**，则为老年代

  - 永久代

    存储存在于**方法区内**的对象，而方法区保存类结构和类变量static A a = new A()

- **判断java的垃圾**

  - 引用计数法

    在对象中添加一个**引用计数器**，当有引用指向该对象时候就+1，引用不指向该对象的时候则-1，当计算器的值为0时视为垃圾

  - 可达性分析算法

    把**GC Root**对象，如本地方法栈、虚拟机栈、方法区里的对象作为**根节点**，作为根节点**向下遍历**，其他与之**没有引用关系**的对象就视为垃圾
  
- **垃圾回收算法**

  - Copying（复制）算法
  - Mark-Sweep（标记-清除）算法
  - Mark-Compact（标记-整理）算法
  - Generational Collection（分代收集）算法

- **jvm垃圾回收机制**

  先判断什么对象是垃圾，使用什么算法进行回收
  
- **垃圾回收器**

  - 新生代使用

    - Serial收集器`[ˈsɪəriəl]`串行

      复制算法

    - Paraller收集器`[ˈpærəlel]`并行

      复制算法

  - 老年代使用

    - Serial Old收集器 

      标记-整理算法

    - Paraller Old收集器

      标记-整理算法

    - CMS收集器

      标记-清除算法

  - 怎么搭配：以上两种年代的多种可以进行搭配

  - **G1垃圾回收器**

    **高吞吐量**的垃圾回收器，整体采用标记-整理算法，局部采用复制算法

- **虚拟机栈的组成**

  由栈帧组成，栈帧包含以下

  - 局部变量表

  - 操作数栈

  - 动态链接

  - 方法返回地址

    

  

# MySQL

- **事务特点特性**

  - 原子性
  - 一致性
  - 隔离性
  - 持久性
  
- **DDL与DML**

  - DDL

    数据**定义**语言，创建、修改表

  - DQL

    数据**查询**语言

  - DML

    数据**操控**语言，CRUD
    
    manipulation操控[məˌnɪpjuˈleɪʃn]
    
  - DCL

    数据**控制**语言

    授权或回收权限

- **索引**

  - 优点
    加快访问速度
    确保该列数据的唯一性
  - 缺点
    创建索引、维护索引会消耗一定量的时间
    创建索引会占用一定量的物理空间

- **事务实现方式**

  - 编程式事务实现

    使用**TransactionTemplate**

  - 声明式事务实现

    - 添加@Transactional
    
    - 使用**aop**实现事务 
    
      在`<tx:advice>`指定事务隔离级别和回滚等配置，在`<aop:config>`的 `<aop:pointcut`>配置切点的表达式，即需要实现事务管理的类，指定前面配置的通知advice

- **事务原理**

  - Spring对事务的操作无非是commit()、rollback()，而这些方法依赖于**数据库对事务的支持**，即Spring的rollback()是调用数据库的回滚方法

    当@Transactional里某个方法的某条SQL语句执行失败后，Spring的回滚方法会调用数据库事务回滚操作

- **事务失效怎么办**

- **SQL注入**
  
  - 无预编译的sql语句，传递的参数可以作为SQL语句的一部分，故可以把传入的参数加上一段sql语句，例如加上where username="" or true or password=""会导致输什么密码都验证通过
  
- 预编译的sql语句，会先将除参数外的sql语句拿去编译，编译后再加上参数，使得该参数只能添加参数类型的数据，而不能让参数加上sql语句段
  
- **预编译实现**

  - 使用`where username = #{}`书写sql参数语句块，Mybatis**调用数据库连接对象**对sql语句进行预编译，对传入的参数进行参数类型校验后注入sql语句

- **数据库三范式**
  
  - 第一范式
  
    每一列都是不可再分的属性、属性相近或相同的列应该**合并**
  
  - 第二范式
    
    如果某些列经常出现数据重复，应该把这些列作为**另一个表**
    
    如订单表有id、用户身份证、用户地址，如果用户下了2个订单，那身份证、地址会重复两遍，可以把身份证、地址作为另一个表，与原表通过外键相关
    
  - 第三范式
  
    每一列都只能依赖于**主键**，即直接与主键相关
  
- **五大约束**

  主键约束、外键约束、非空约束、默认约束、唯一约束、

- **对数据进行切分**

  - 水平切分

    按每一行数据的某个字段作为切分标准

  - 垂直切分

    按列把表切分成多个表

- **自增主键和随机主键UUID区别**

  - 自增主键插入新行我们不需要添加主键值
    jdbcTemplate.update(INSERT INTO 表名 (name) VALUE(？),"test");
  - 随机主键插入新行我们需要添加主键值，可以自己添加或使用UUID
    jdbcTemplate.update(INSERT INTO 表名 (id,name) VALUE(？,?),UUID.randomUUID().toString(),"test");
  - 自增主键的性能比随机主键好

- **索引类型**

  - 普通索引

    其他索引是在普通索引的基础上，添加了某些特征

  - 主键索引

    不允许空值

  - 唯一索引

    允许空值

  - 组合索引

    ```sql
    ALTER TABLE `table` ADD INDEX name_city_age (name,city,age);
    ```

    指对**多个字段**创建一个索引，遵循最左前缀匹配原则

    适用于多个列**必须在一起使用**的场景如，where f1 = 1 and f2 = 2s and f3 = 3

  - 全文索引

    查找列的文本中某个**关键字**

- **聚簇索引、非聚簇索引**

  主键索引是聚簇索引的一种特殊形式，把主键列作为索引字段

  - 非聚簇索引

    每一行的数据之间不紧凑在一起

    索引树的叶子节点保存的只是**该列的值**

    找到了索引，还要根据该索引保存的字段，再根据该字段去查找行

  - 聚簇索引

    索引树的叶子节点保存了**整行的数据**

    设置行数据的存储顺序，与行数据的物理存储顺序相关，eg：1和2紧凑在一起存储

    **索引和行数据保存在一起**，找到了索引，就找到了该行数据

- **聚簇索引、非聚簇索引何时择优使用**

  - 查询一定范围内的数据，使用聚簇索引

    因为关键点`一定范围内`，因为`通过聚簇索引建立的索引树，的每一行的行数据的物理存储顺序都是紧凑在一起的`，只需要检索最小值索引与最大值索引，就可查出该范围内的所有数据

- **索引优化**

  - 选择B+树索引，要查找一定范围内数据再添加聚簇索引
  
- **最左匹配原则**

  - **联合索引**

    在一个表中设置多个字段是索引列

  - **最左匹配原则**

    - 在查询时，必须添加**第一个**索引列，否则查询**失效**，且查询条件遇到**范围**查询，执行了这个范围查询后就会停止匹配
    
      - **原理**
    
        建立索引树时，会先根据**第一个**索引列进行排序，之后再根据第一个索引列排序后的**基础上**，根据第二个索引列进行排序，故第一个索引列在B+树上是有顺序的，而其他索引列是无序的，没有添加第一个索引列就会执行失败
    
      - 在第一个索引列的值一定的情况下，第二个索引列是有顺序的


- **MySQL锁**

  - 行锁

    某线程a对某一行进行加锁，则其他线程对该行的写操作都会被阻塞，直到线程a释放行级锁

    事务a更新某一行，事务b也要更新该行，则事务b必须在事务a执行完后才可执行

  - 表级锁

    某个线程a对该表执行了`lock tables t wirte`，则其他线程对该表的写操作都会被阻塞，直到线程a释放表级锁

  - 全局锁
  
    把整个数据库设置为只读状态，则对该数据库的其他操作都会被阻塞

- **分库分表**

  - 垂直切分
    
    - 垂直分表：表的**列过多**，把一张表按**列**垂直切分为多张表
    
  - 垂直分库：把数据库按业务进行分库，用户一个库、订单一个库，每个库存储在不同的服务器上
    
      数据库每秒需要执行的查询总数过高，导致数据库连接不足
    
      QPS，Query Per Second每秒查询总数[pə(r)]
    
  - 水平切分
    - 水平分表：表的**行过多**，把一张表按**行**切分为多张表
    
      行过多造成数据检索速度慢、可存储的空间不足
    
    - 水平分库分表：把一张表存储在不同的服务器上，每个服务器都有相同表和库
    
      数据库每秒需要执行的查询总数QPS过高 + 单表已存储的数据量过大


- **MyISAM与InnoDB的区别**

  - 都是数据库引擎

    > [my ai sem]

  - InnoDB支持事务和外键，而MyISAM不支持

  

- **CAS原理**

  >  compare and swap，无锁解决线程冲突的理论原理，表现形式为乐观锁

  - 在多线程共享同一变量的**场景**下，**写数据时**，对于内存中某一个变量，提供了预期值，当该变量和预期值相等时，把**新值写入**内存值

    因为**CAS操作**的比较和替换是**原子操作**，则不怕多线程干扰

    ```java
    do{
    	V = B;
    } while(V == A)
    ```

  - probleams

    因为是乐观锁，大量失败后会占用系统的过多资源

- **ABA问题**

  - CAS算法把内存值修改为A，修改为B，再修改为A，CAS算法不能感知到内存值曾经发生过变化
  - 解决：给变量添加版本号

- **MVCC原理**

  > 无锁解决读写冲突的理论原理
  >
  > Multi Version Concurrency Control多版本并发控制         `[ˈmʌlti]多`

  - **作用**

    原先的数据库在并发的情况下，读写必须在加锁环境下进行，而MVCC实现了在**不加锁**的条件下解决了**读写冲突**

  - **实现方式**

    - 每条行数据都保存了两个**隐藏的列**，分别记录行数据的创建、过期时间

      |          | ID   | NAME     | 创建时间 | 删除时间  |
      | -------- | ---- | -------- | -------- | --------- |
      | 创建操作 | 1    | hdgaadd  | 1        | undefined |
      | 更新操作 | 1    | hdgaadd6 | 2        | undefined |
      | 删除操作 | 1    | hdgaadd  | 2        | 5         |

      - 创建操作是添加了创建时间，过期时间**默认**
    
      - 更新操作是**添加**了另一条行数据，重新设置创建、过期时间

        并为原数据设置过期时间

      - 删除操作是**设置**过期时间
    
    - 而读操作只能读取**创建时间=<**当前读时间，**过期时间>=**当前读时间的行数据，故确保了读写的一致性
    
      创建、过期时间不是实际的时间，而是会递增的**系统版本号**的表现形式

- **并发事务带来的问题**

  > 本质是多个事务同时发生带来的问题

  - 脏读

    一个事务读取到另一个事务未提交的数据

  - **不可**重复读

    一个事务多次读取同一数据，另一个事务**修改了**该数据，导致第一个事务第二次读取数据发现和第一次读取的**数据不一致**

  - 幻读

    一个事务多次读取同一数据，另一个事务给这些数据**插入删除了某些内容**，导致第一个事务数据的**数量**发生改变

  - **丢失修改**

    一个事务修改了某个数据，另一个事务与其读取同一数据且**原始值**都相同，另一个事务修改数据后提交，导致第一个事务的修改操作丢失

- **隔离级别**

  解决**并发事务**造成的数据不一致问题

  - 读未提交

    > READ-UNCOMMITTED

    **允许**读取未提交的数据

  - 读提交

    > READ-COMMITTED

    **不**允许读取未提交的数据

  - 可重复读

    > REPEATABLE-READ[rɪˈpiːtəbl]

    事务读取数据后，就将数据**加锁**，确保了不被其他事务修改造成不可重复读的问题

    **默认的隔离级别**

    解决了脏读、不可重复读

  - 序列化

    > SERIALIZABLE[ˈsɪərɪəlaɪzəbl]
    
    设置并发事务的**执行顺序**，防止了事务之间相互干扰的任何情况

- **设置隔离级别的command**

  - 查看

    > [ˌaɪsəˈleɪʃn]隔离

    ```sql
    select @@tx_isolation
    ```

  - 设置

    ```sql
    set session transaction isolation level repeatable read
    ```

    

- **幻读解决**

  - 设置间隙锁，在两个索引值之间的数据进行加锁，杜绝了其他事务在这个范围内对数据数量的影响
  - next-key锁

- **外键与级联**

  - 不建议使用外键

    外键所关联主键的更新与删除，会产生**级联更新与删除**，**不适应**分布式、集群系统

    且外键影响数据库的**插入速度**

- **一条SQL是如何执行的**

  - 查询语句

    - 调用连接器：判断用户是否已经**登录**
    - 根据SQL检查该SQL是否**命中缓存**，MySQL8.0已经废弃该点
    - 调用分析器：提取SQL的**关键字**
    - 调用优化器：以MySQL认为**最优**的方式去执行该SQL
    - 调用执行器：判断该用户是否有**权限**执行该SQL，有则调用**存储引擎**的接口，返回结果

  - 更新语句

    - 像查询语句**一样调用**连接器、分析器、优化器去**获取数据**
    - 接着把**获取到的数据**，修改后放在内存中，同时把这条数据的修改日志记录在redo log`[ˌriːˈduː]` ，且把redo log的状态设置为**prepare状态**
      
      - 调用执行器：把这条数据的修改日志记录在**binlog**
  - 调用存储引擎接口写入数据，且把redo log状态设置为**提交状态**
    
  - 使用两个**日志配合**可以确保在数据库**异常重启**不会发生数据不一致问题
    
      我认为`这两个日志的作用是否都是备份数据、备份的时候谁主谁次`，决定了为什么要设置redo log两个状态与把日志先写入谁

- **MySQL读写分离**

  - what：在主数据库上**写**，在从数据库上**读**

  - why：解决大量数据库修改增加给数据库带来的性能压力，造666666666成数据库查询效率变低

  - how

    1. 使用中间件**Mycat**在后端层面上对数据库操作进行拦截 

    2. 构造多个**连接池**，使用**Spring AOP**在服务层拦截数据库请求，写操作使用主数据库连接池，读操作使用从数据库连接池

       读写分离怎么保证数据同步

- **MySQL主从复制**

  > 也叫主从同步，从库通过主库进行数据更新

  - 主库将**数据变化**写入binlog
  - 从库连接主库，获取**binlog**，将binlog写入relay log
  - 从库读取**relay log**进行数据同步
  
- **慢查询**

  - 指开启慢查询日志，启动后MySQL会**记录**查询超时的SQL语句

- **MySQL性能优化**

  - **架构设计**层面

    采用MySQL主从集群

    采用分库分表机制，分库降低单个服务器压力、分表提高SQL查询数据

    热点数据使用访问更高效的，非关系型数据库

  - SQL**语句**层面

    - 以下的索引优化

    - 查询结果明确只有一条数据，在后缀添加LIMIT 1

      MySQL匹配查询后则不会继续扫描

    - 切分查询，把大查询切分成小查询，因为mysql进行小查询很高效

  - MySQL**配置**层面

- **MySQL索引优化**

  > 索引失效即进行全表扫描

  - 从**选择合适**索引列的角度
    
    - 索引列应该选择小字段、经常出现在WHERE、经常进行多表连接的列
    
  - 从**不要让索引失效**的角度，进行索引优化
    
    - 不能对索引列进行**数学函数**处理，否则索引失效
    
    - 索引是字符串类型，查询值必须添加**单引号**''，否则索引失效
    
      值类型与索引列类型不一致，MySQL**不会使用**索引，而是把索引列数据进行类型转换后进行查询
    
    - 对索引列进行模糊查询，%要放在**最右侧**，否则索引失效
    
      SELECT * FROM user WHERE name LIKE n**%**
    
  - 使用explain关键字
  
- **explain关键字**

  - 模拟执行sql语句，查询出sql语句**执行的相关信息**，如哪些索引可以被命中、哪些索引实际被命中、查询出表中多少行数据
  - 也称为**执行计划**

- **MySQL默认的隔离级别是**

  - 可重复读

- **为什么使用B+树索引**


  - **IO次数更少**

    相比B树结构，一个节点可存储的元素个数更多，树型结构更加矮胖，使访问数据时IO次数更少

  - **范围查询**效率更高

    索引值都存放在**叶子节点**，并使用**链表**连接，找到范围的最小值即可向右查找所需数据

  - 查询更加**稳定**

    每个数据查询，B树所需走的**路径长度**都是不同，而B+树所有值都在叶子节点，所走的路径长度都是从根节点到叶子节点，查询更加稳定

- **B+树的叶子节点**

  使用双向链表连接

- **MySQL日志文件类型**

  - binglog

    二进制日志

    记录数据库的**写入**操作

  - redo log

    事务日志

    记录事务操作时，数据的变化

  - undo log

    事务日志

    记录事务操作时，数据的原始值

- **MySQL视图的作用**


  - 视图可以**存储经常使用**的查询sql，下次要**再执行**该sql语句，只需调用了该视图即可

    ```sql
    create view viewName
    as
    select * from test 
    
    select * from test 可改为 select * from view
    ```


      - 修改**表结构**时，如修改了表名，则后端程序的相关sql会失**效**

        可以创建name为**原表名的视图**，此时后端select * from user，查询的该user是视图

- **分库分表后id如何创建，确保多个数据库服务器的Id不会重复**


  - 把当前时间作为id
  - 每个服务器的数据库id的值，设置不同的前缀

  





# Redis

- **缓存穿透**

  - 大量的请求的key都**不存在**于Redis，导致这些大量请求都落到了数据库上

  - **解决方法**

    - 确保**命中率比较高**的数据都保存在Redis里

    
    - 确保key的合法性，使用布隆过滤器，把**所有可能请求**Redis**的key**都保存在布隆过滤器，如果请求的key在布隆过滤器**找不到**，则抛出参数异常给服务器
    
  - **使用布隆过滤器**

    - 以**插件形式**安装布隆过滤器
    - 每次添加键值对，往布隆过滤器添加
    - 用户每次获取key，要先去布隆过滤器判断是否有值

- **缓存雪崩**

  - Redis缓存的数据在同一时间大面积失效，导致大量请求都落到了数据库上

  - **解决方法**

    失效的原因有**两个**

    - Redis服务本身失效

      设置Redis集群，防止一个Redis服务失效就导致缓存雪崩

    - Redis的键过期失效

      设置键过期时间更长

- **怎么保证redis和数据库同步**

  1. **双更模式**

     1. **先更新缓存，后更新数据库**

       如果更新数据库失败，则出现数据不一致

     2. **先更新数据库，后更新缓存**

       俗称**双写**，如果两个线程同时更新数据库，先操作数据库的线程，在更新缓存的时候，比后一个线程慢，将导致更新的缓存是脏数据

  2. **删除模式**

     1. **先更新数据库，后删除缓存**

       - **problem**

         - 缓存失效了，A查询数据，因缓存失效查询数据库后是旧值，B更新数据库，后删除缓存

           - 若A在B操作之后把旧值写入Redis，就会产生数据不一致

           - 若A在B操作之前把旧值写入Redis，B更新完数据库还会再删除缓存，此时不会产生数据不一致

             一般都是A在B操作之前，因为A的读数据库比B的写数据库快

         - 主要担心的是**删除缓存失败**

           可以采用**重试机制**

       - **适应面**

         - 在更新数据库期间，旧缓存会被读取，造成**短时间**的数据库不一致

           适合对数据一致性**要求不太高**的系统

     2. **先删除缓存，后更新数据库**

       - **problem**

         - 缓存失效了，A查询数据，因缓存失效查询数据库后是旧值，B删除了缓存，后更新数据库，此时接下来A会把旧值写入缓存，造成数据不一致

         - 采用**异步更新缓存**

           即缓存失效，查询数据库后不会**立即更新缓存，**等数据库更新完再更新缓存

       - **适应面**

         - 采用**异步更新缓存**，在数据库更新期间，都是直接读取数据库，造成数据库压力大

           适合对**数据一致性要求高**的系统
       

  - **knowledge**
    - redis更新不是在redis进行更新，而是删除redis缓存后，会重新获取数据库数据

- **redis实现分布式锁**

  - 使用Redis驱动jar包，Redisson

  - 使用redis命令

    以下操作需要**命令行操作**Redis，也是**使用**Redis驱动jar包**实现**

    - 设置客户端要操作redis默认需要申请到锁资源，即加锁成功
    - 客户端a对redis执行：SETNX mylock "mylock"，如果返回1则**加锁成功**，则其他客户端申请加锁会返回0
    - 客户端a操作完成后释放锁资源
    - 保证加锁和设置锁过期时间为原子性操作：SETNX mylock "mylock" EX 10 NX        `10s过期`

- **Redis持久化机制**

  > Redis是一种基于内存的数据库，为了保证数据不丢失，提供了两种数据持久化机制
  >

  - RDB持久化机制

    - 在**一定时间间隔**，生成内存中整个数据集的一个RDB快照文件，名称为**dump.rdb**

    - **实现**

      默认开启RDB，编写命令**save**，即可保存名称为**dump.rdb**的快照文件

  - AOF持久化机制

    - Redis会将所有的写操作都保存在一个AOF文件，重启Redis执行该aof文件即可恢复redis的所有数据

    - **实现**

      默认是关闭的，需在配置文件启动，即可生成appendonly.aof文件

      ```
      appendonly no // 设置为appendonly yes，[əˈpend] 
      ```

      

- **redis过期删除策略**

  - 惰性删除：**放任过期的键不管**，每一次**获取键**的时候判断该键是否过期，过期则删除，否则返回

    对CPU更友好

  - 定期删除：redis的activeExpireCycle`[ɪkˈspaɪə(r)]`函数，每隔一段时间随机取出**一定数量**的键，删除掉已经过期的键
  
    对内存更友好
    
    > 使用LRU算法取出一定数量的键           Least Recently Used最近最少使用

- **Redis内存淘汰策略**

  > 前提是设置了Redis的**最大内存限制**，当内存到达最大量时，sRedis就会执行内存淘汰
  >

  - **种类**

    - allkeys-random：进行**添加key**操作时，Redis判断该操作会到达内存最大量，则**扫描所有**key，**随机**淘汰某些key
    - volatile-random`[ˈvɒlətaɪl]`：进行**添加key**操作时，Redis判断该操作会到达内存最大量，则扫描那些设置了**过期时间**的key，**随机**淘汰某些key

  - **设置**

    ```
    maxmemory 300mb // 设置最大内存限制
    
    maxmemory-policy noevictions // 设置内存淘汰策略[ˈpɒləsi]策略
    ```

    

- **Redis读写策略 **

  > 新数据插入时

  - **旁路**缓存模式

    先更新数据库，再更新Redis

  - 读写**穿透**模式

    把Redis作为**主要的**数据存储，更新数据先更新Redis，再**同步更新**数据库

  - **异步**缓存模式

    把Redis作为**主要的**数据存储，**先**更新Redis，把更新数据库的请求先保存起来，**异步**地更新数据库

    这种模式数据不一致的概率比较大，因为Redis**失效**而异步的更新数据库请求还没执行，则读取到的都是旧数据，但是适合读写操作大，对数据一致性要求性不高的**场景**，例如阅读量、点赞量

- **LRU**

  > 最近最少使用算法Least Recently Used

  - 当Redis的**缓存空间不足**时，若有新数据添加，需要将最不可能访问的数据删除掉





# RocketMQ

- **消息队列有什么作用**

  - **流量削减**

    在高并发环境下，把大量请求创建的**任务消息**都暂时**存储**在RocketMQ里，防止大量请求直接冲击服务器，**降低**服务器的**压力**

  - **异步处理**

    用户执行某一请求触发某个任务，把任务以Message对象的形式保存在消息队列，先返回给用户结果，**不等**消息队列的任务处理**完成**，达到速响应用户的操作

  - **解耦**

    发送该任务请求的程序，与该具体实现任务的程序是**解耦**的，发送任务请求的程序**不用管**任务的**具体实现**

- **消息队列的缺点**

  - 降低系统可用性

    如果消息队列功能失效，导致该模块的任务就无法正常运行

  - 提高系统的复杂度

    我们的程序需要处理加入消息队列，带来的**数据不一致性问题**：3个队列任务，其中一个修改数据库失败怎么办

- **RocketMQ有什么角色**

  - NameServer

    保存Topic、Broker信息，Broker启动时需要向NameSercer注册

  - Broker

    **RocketMQ本身**，[ˈbrəʊkə(r)]作为RocketMQ实现消息的收发，的**服务器**

  - Producer

    消息生产者

  - Consumer

    消息消费者

- **RocketMQ的执行过程**

  - 启动NameServer
  - Broker在启动时向NameServer**注册**，保持**长连接**，每隔一段时间**发送心跳**
  - Producer发送消息时，从NameServer获取Broker**服务器地址**，**负载均衡**地选择Broker发送消息
  - Consumer同上

- **RocketMQ的消费模式**

  - 集群消费

    每一个Topic发送，同一个消息分组，只有**一个**消费者消费消息

    **默认是**集群消费

  - 广播消费

    每一个Topic发送，同一个消息分组，分组里**所有**的消费者都会消费该消息
    
  - **配置**

    实例化**消费者配置类**，使用setMessageModel()进行配置

- **RocketMQ如何保证消息不丢失**

  - Producer层面

    消息发送失败，进行**消息重试**

  - Broker层面

    建立**集群部署**，确保高可用

  - Consumer层面

    消息消费成功与否都进行**通知**，掌握哪些消息消息失败

- **死信队列**

  - 消息消费失败，多次进入重试队列，进行消息重试**仍然失败**，该消息就会进入死信队列

    有效减少了不断重试消息，对系统性能的消耗
    
  - **获取与处理**
  
    - 在**RocketMQ控制台**查看死信队列
    - 支持将死信队列里的消息进行重新发送
  
- **事务消息**

  > **实现事务**的消息队列消息，称为事务消息，以确保事务的**原子性**
>
  > 也称为半消息

  - 服务器1执行事务操作1时，**消息生产者**向服务器2发送**preferred**消息，确保两者的**连接成功**
  - 接着服务器1执行事务操作1，根据操作的成与败，向服务器2的消息队列发送**confirm**或**cancel**消息
  - **消息消费者**若接收到**confirm**消息，则执行事务操作2

# Elasticsearch

**Elasticsearch是什么**

- 是一个非关系型的数据库，内置了分布式的**搜索**引擎和数据分析引擎

- 功能

  - 作为搜索引擎可以相比关系型数据库，对于**非结构化的纯文本数据**，查询效率更高效

    拥有倒排索引

  - 支持分布式架构，能够把**海量数据**，**实时分散**存储到**多台**服务器里，进行数据的存储与处理

    实现海量数据的实时处理

**倒排索引**

- 对有keyword修饰的字段的所有值，**分词**成多个单词，使用记录表**记录**每个单词所在的document的**id**，此时每个单词和记录表是一一对应的，接着对每个单词进行**字典树排序**

  查询的时候就根据记在字典树查找该单词，再根据该单词找到对应的记录表

**增量编码**

- 记录表存储了document的id，原本是[100, 200, 300]

  只需要存储第一个id的值，后面id的值存储**增量**即可，修改为[100, 100, 100,]，减少内存空间消耗





# OAuth2

**什么是OAuth2**

- 实现了在本软件可以使用第三方的资源

- 实现步骤

  后端**申请**访问资格 -> 用户点击微信登录，**跳转到**微信软件进行授权 -> 用户点击确认 -> **授权服务器**提供**授权码**给后端 -> 后端通过授权码再访问授权服务器，获得**令牌** -> 后端通过令牌获取**资源服务器**用户信息

# Seta

- **分布式事务和本地事务的区别**

  - **分布式事务**

    - 在**分布式**系统环境下，一个大事务包含了多个**数据库操作**，这些操作**分布在不同**的服务器里面，分布式事务确保这些小操作具有原子性 
  - **本地事务**
    - 在**单体**服务环境下，一个事务包含了多个数**据库操作**，本地事务确保这些数据库操作具有原子性

- **分布式事务解决方案**

  - TCC模式
  - MQ模式
  - Saga
  - 2PC
  - 3PC

- **TCC模式**

  补偿性事务，Seata是TCC模式的具体实现

  我的Seata项目，代码实现的是Confim、Cancel阶段，Try和Cancel没有实现

  - Try阶段

    **锁住**分布式事务的各个小操作，所需的**业务资源**如库存

    该Try操作要我们**实现**

  - Confirm阶段`[kənˈfɜːm]`

    如果Try阶段无异常，**执行**分布式事务小操作，失败则执行**各个服务**的Cancel

  - Cancel阶段`[ˈkæns(ə)l]`

    **回滚**各个服务器的事务，**释放**业务资源
    
    也需手动实现

- **2PC模式**



# Gateway

> 非alibaba，对标Netflix的Zuul

**Gateway的作用**

- 请求转发
- 请求认证授权、限流







# Netty

- **什么是Netty**

  - Netty是一个基于**Java NIO**的网络应用框架，相比其他网络应用框架提供了简单易用的API，简化了基于TCP/UDP的网络应用编程开发

- **Netty的特点**

  - 基于NEW IO同步非阻塞IO的框架，一个系统线程**处理多个**读请求，高并发性能好
  - Netty的传输具有**零拷贝**特性，传输速度快
  - 封装了大量NIO接口，调用方便

- **IO模型**

  - BIO：`Blocking IO，同步阻塞IO模型`

    应用程序**调用读操作**后，会一直**阻塞**，直到内核把数据拷贝到用户空间才进行**获取数据**

    操纵系统一个线程**处理一个**读请求

  - NIO：`NEW IO，I/O多路复用模型`

    应用程序**调用读操作**，首先发送**select调用**询问数据是否准备好了，应用程序在询问，到内核把数据拷贝到用户空间的过程中**不阻塞**，准备完成后内核通知应用程序，则进行**获取数据**

    操纵系统一个线程可以**处理多个**读请求

  - AIO：`异步非阻塞IO模型 asynchronous[ɪˈsɪŋkrənəs]`

    应用程序**调用读操作**，直接返回结果给应用程序，等到内核把数据拷贝到用户空间后，操作系统**自动把**数据从用户空间**传输到**应用程序

    操纵系统一个线程处理一个**有效**请求

    **同步异步阻塞**

    - 阻塞：进行读操作后**到**内核将数据拷贝到用户空间**是否**阻塞

    - 同步：应用程序直接参与IO读写；异步：IO读写交给操作系统去执行

      > 同步异步不用管，也就AIO异步，其他都同步

- **Channel是什么**

  - NIO模型进行**IO操作**使用的操作对象，用来进行数据的读写

    标准IO使用**Stream流**，进行数据的读写

  - Channel本身不能直接访问数据，必须**基于Buffer**

    - 通过Buffer在管道读数据

      ```
      ByteBuffer buffer = ByteBuffer.allocate(30); // 通过Buffer指定要读取的数据长度
      fc.read(buffer);
      System.out.println(new String(buffer.array()));
      ```

    - 通过Buffer在管道写数据

      ```
      ByteBuffer buffer = ByteBuffer.wrap("hello Channel\n".getBytes()); // 通过Buffer指定写入数据
      fc.write(buffer);
      fc.close();
      ```

      

- **Channel和Stream流的区别**

  - Stream流是单向的，而Channel是**双向**的，可读可写

    Stream流读写**分别使用**FileInputStream、FileOutStream，而Channel读写都是同一个对象

  - Channel可以**非阻塞**的读写，而Stream流只能阻塞地读写

  - Channel的读写是**基于Buffer**，而普通流是基于本身

- **NIO为什么可以高并发**

  从各个IO模型高并发场景下的系统开销角度上看，NIO更适合，因为一个线程**处理多个**请求，而BIO一个线程处理一个请求，

- **Netty应用场景**

  - 微服务项目之间服务与服务之间的相互调用必须使用RPC框架，而Netty可以作为RPC框架的网络通信工具
  - 即时通讯系统
  - http服务器，如Tomcat服务器

- **Channel是什么**

  > Socket是什么：Socket是处于应用层和TCP/UDP之间的抽象层，我们可以使用Socket在TCP/UDP协议上对数据进行接收、获取和处理

  Channel的解释同上

  Tomcat通过new ServerSocket().accept()创建该某个端口监听的Socket对象，Channel相当于一个Socket对象

  

- **长连接与心跳机制**

  - 短连接：客户端与服务端请求响应完成后就断开连接，每一次请求都要重新连接

    长连接：客户端与服务端一直保持连接，但长连接的**问题**在于如果两端之间发生断网等网络异常，彼此之间无法发现对方已经掉线

  - **心跳机制**

    > 确保客户端和服务端都**正常执行**，**连接可以成功**，即确保长连接无异常

    - **实现**
      - 客户端每60s向客户端的Channel实例发送一个IdleStateHandler事件对象，接着客户端接收到IdleStateHandler事件对象就会触发向服务端发送消息，即为**发送一次心跳请求**
      - 服务端接收到心跳后，向客户端Channel实例发送心跳响应消息

- **Netty零拷贝**

  - 操作系统层面上的拷贝

    **实现网络发送数据需要执行**

    1. 数据从磁盘读取到内核缓冲区
    2. 数据从内核缓冲区**拷贝**到用户缓冲区
    3. 数据从用户缓存区**拷贝**到内核socket缓冲区
    4. 数据从内核socket缓冲区转发到网卡缓冲区

    > 取消了2、3步的操作，直接将数据从磁盘拷贝到内核缓冲区，再从内核缓存区拷贝到网卡缓冲区，则称为零拷贝

  - Netty零拷贝

    - Netty接收二进制数组ByteBuf，直接将二进制数组**分配到内存空间**，再把数据从内存空间转发到网卡缓冲区，无需进行数据拷贝
    - Netty组合两个二进制数组ByteBuf，不用使用两个数组复制后创建一个新数组，而是**保存了他们的引用**，对引用进行组合从而实现数据的组合
    - Netty使用**FileChannel的transferTo()**实现零拷贝，而该方法依赖于底层操作系统实现



# Dubbo

- **注册中心有什么用**

  进服务注册与服务地址提供

- **注册中心挂了还可以通信吗**

  可以，因为服务消费者会把服务提供者的地址等信息**缓存**到本地

- **Dubbo负载均衡的策略有哪些**

  - RandomLoadBalance

    **随机**地调用服务

  - RoundRobinLoadBalance

    **均匀**地调用每个服务，可以设置调用的权重

  - LeastActiveLoadBalance

    **感知**哪个服务的性能更差，则更少地调用该服务，该服务也就不活跃

  - ConsistentHashLoadBalance

    把**某一类**请求都调用固定一个服务

- **服务降级**

  把某服务当成一个**实现类**，当该服务失效时，调用一个**处理服务失效**的实现类，称为服务降级

- **分布式服务接口的幂等性**

  - 有多个分布式服务接口**都是**处理支付的接口，需保证**一次**支付请求过来，不会导致**支付多次**

    因为可能由于**网络延迟等**，造成一次支付请求，发送到**多个**支付服务接口

  - Redis保存唯一的订单id的**支付状态**，若下次请求发现订单状态是已支付，则不会再执行支付流程
  
- **分布式服务接口，对多个请求的顺序性如何保证**

  - 两个请求，一个执行订单的插入，一个执行订单的删除，确保删除在插入之后，即必须删除
  - **solevd**
    1. 使用消息队列，把多个请求都经过一个某机器里的**消息队列**的排队，先进先出地分发到分布式服务接口中去，上一个请求执行完毕，再执行队列下一个请求
    2. 把插入、删除**合并**为同一个操作，即不用设计以上而提高系统复杂度





# Sentinel



# Zookeeper

**是什么**

- 相当于**文件系统 + 通知机制**，每一个子目录都是一个**znode**，可以在任意一个znode下添加新的znode

  基于以上的特点可以使用Zookeeper来创建以下

  - 集群管理

    即注册中心

  - 分布式锁

  - 配置管理

  - 名字服务

    网关

**如何实现分布式锁**

1. 将ZooKeeper某个znode看成锁，每个服务要执行得先去该znode目录下**创建子目录**/distribute_lock，谁**先创建**则获得锁

   执行完删除目录即释放锁  `分配[dɪˈstrɪbjuːt]`

2. 目录/distribute_lock已经存在，所有服务在该目录创建有**顺序编号**的znode，编号**小**的服务获得锁

**Zookeeper的集群模型是什么**

- 一主多从

  leader负责写请求，follower和observer负责读请求










# 架构设计与系统部署

- **部署概念**

  - 分布式部署

    **不同**的业务模块，部署在**不同**的服务器上

    **系统部署**方式，主要是为了**提高**系统性能

  - 集群部署

    **一个**业务模块的程序，**复制**部署到**多台**服务器上

    **系统部署**方式，主要是为了确保系统的**高可用性**

  - 微服务

    **不同**的业务模块，分为不同的**服务**，但是不同的服务可以部署在**同一台**服务器上

    **架构设计**方式，微服务的概念就是为了**解决**，**某一个**功能模块的失效或更新导致的整个项目必须停止运行的问题

- **CAP理论与BASE理论**

  辅助分布式系统设计的理论

- **CAP理论**   

  > consistency一致性[kənˈsɪstənsi]、availability可用性[əˌveɪləˈbɪləti]、partition分区[əˌveɪləˈbɪləti]、tolerance容错[ˈtɒlərəns]

  - 一致性

    所有**服务器节点**访问同一份**最新**的数据

  - 可用性

    所有非故障的服务器节点都能提供服务 

  - 分区容错性

    服务器节点之间如果出现**网络分区**，**依然**能够提供服务

    **网络分区**：网站故障，造成某**正常**服务器被判断为**不可访问**的现象

  - **取舍**

    example：提供数据的服务器1和被判定为**不可访问**的服务器2、认为服务2**不可**访问的服务器3、认为服务2**可以**访问的服务器4

    - CA without P

      **CA要满足**也很难，在单服务系统可以

    - 保证P的**前提**下，说明出现了网络分区，只能

      - CP without A

        **放弃**服务2，把服务1作为**唯一**可用服务器，实现数据一致性

      - AP without C

        让服务器**都可用**，不管访问服务2造成的**数据不一致**

  - **三者不能共存的理由**

    - P的前提下，对服务1进行**写操作**，要确保C一致性，必须**禁止**服务2进行**读写**，而因为网络分区，服务1认为服务2是不可访问的，**禁止**不了服务2进行读写，故**服务1会拒绝写操作**，表现为服务1**不可用**，故不可能实现A

    - P的前提下，对服务1进行**读写操作**，要确保A可用性，则服务2也**提供数据**，而因为网络分区，服务1不能**同步数据**到服务2，造成数据不一致，故不可能实现C

- **BASE理论**

  > basically基本的[ˈbeɪsɪkli]、available可用的[əˈveɪləbl]、soft state软状态[sɒft]、eventually最终的[ɪˈventʃuəli]、consistent一致的[kənˈsɪstənt]`

  基本可用、软状态、最终一致性

  BASE理论是由CAP理论演化而来的

  无法做到**强一致性**，采用适当的方法使系统到达**最终一致性**

- **RPC是什么**

  Remote Procedure Call `远程过程调用[prəˈsiːdʒə(r)]` 

  实现了在本地可以调用远程的服务，而不用关注远程服务的具体实现

- **Spring Cloud Alibaba各个组件**

  - Dubbo

    分布式RPC，主要致力于服务**调用**、负载均衡

    dubbo可以使用**zookeeper**作为服务注册中心

  - Nacos

    分布式注册中心，主要致力于服务**发现**、配置中心

  - Seata

    [si ta]分布式事务

  - Sentinel

    分布式流式控制[ˈsentɪnl]，类似于SpringCloud的Histrix

  - RocketMQ

    分布式消息队列

- **分布式锁实现**

  实现一个方法在同一时间只能被一个机器的一个线程使用

  - 基于数据库
  
    在数据库**字段**设置**唯一性约束**，实现多个请求的情况下，数据库只确保一个请求操作可以成功
  
  - 基于redis
  
    使用Redisson在Redis**创建锁**，每个服务器的方法执行首先会去**获取**分布式锁，获取不到则等待
  
  - 基于zookeeper

 













# 框架

- **AOP都有什么通知**

  - 前置通知@Before：

  - 后置返回通知@AfterRunning：方法不抛出异常，正常退出方法时执行

  - 后置异常通知@AfterThrowing：方法抛出异常后执行         [ˈθrəʊɪŋ]

  - 后置通知@After：一定执行的

  - 环绕通知**@Around**：决定连接点方法是否执行

    在@Around决定执行了目标方法，@Before才会被调用

- **spring循环依赖**

  单例、Setter注入

- **springaop的两种实现方式** 

  - 注解形式

    @Aspect，指定该注解所在包，<`aop:aspectj-autoproxy`>启动事务；      
    @Before前置通知、@AfterReturning抛出异常不执行的后置通知、@After抛出异常仍执行的后置通知

  - xml形式

    1、创建包含拦截器方法的普通类，在`<aop:config>`配置切点、在<`aop:aspect`>指定该普通方法为保存拦截器的方法，配置该普通类的方法为前置通知、后置通知等
    2、创建实现前置通知接口和后置通知接口的类，在<`aop:config`>配置切点，<`aop:advisor`>指定保存该实现前置通知接口和后置通知接口的类

    `<aop:aspect>`多用于日志处理，`<aop:advisor>`多用于事务管理         

- **@RestController和@Controller区别**
  
  - @RestController是@ReponseBody+@Controller，而@ReponseBody可以将后端返回的java对象转换成join格式的数据
  
    ```java
    @ReponseBody
    public User test(){
      User user=new User();user.setName("666");
      return user;}                 //不加注解浏览器得到的数据是[Object]；加上是{"username":“666”...}
    ```
  
  - 添加上@RestController不能跳转到某个页面，而@Controller可以
  
- **Bean的三种装配方式**
  
  - @Component
  - @Configurations+@Bean
  - xml配置
  
- **bean的作用域==bean的类型==bean的生命周期==spring作用域==spring的作用范围**
  
  - singleton
  
  - prototype
  
  - request
  
    每次http请求都会创建一个新的bean
  
  - session
  
    使用同一个session的请求会共享一个bean
  
  - global session
  
    同一个全局的session会共享一个bean


- **spring框架使用到的设计模式**

  - 工厂方法模式

    spring拥有许多Factory工厂，工厂的实现是推迟到子类

  - 单例模式 

    bean的类型是single
  


- **何为线程不安全**

  多线程操作同一共享变量，出现数据不一致情况
- **解决单例Bean线程安全**
  - Bean中尽量不要定义成员变量
  - 使用ThreadLocal存储当前操作的Bean的成员变量


- **对Sping MVC的理解**
  
  Spring MVC是Model、Controller、View的简写，把数据、业务逻辑、最终显示视图分离开来，相比之前的把数据业务逻辑最终显示视图都耦合在一个JSP页面，开发变得更高效，更加具有可维护性可扩展性
  
- **事务传播行为**

  > @Transactional(popagation = PROPAGATION_REQUIRED)

  - PROPAGATION_REQUIRED

    `[ˌprɒpəˈɡeɪʃn]传播`

    若调用它的方法是一个**普通**方法，则它是一个**事务**方法

    若调用它的方法是一个**事务**方法，，则它会加入调用的方法的事务

    ```java
    @Transactional(propagation = PROPAGATION_REQUIRED)
    public void methodA() {
    	methodB();
    }
    
    @Transactional(propagation = PROPAGATION_REQUIRED)
    public void methodB() {
    	
    }
    ```

    

  - PROPAGATION_SUPPORTS

    若调用它的方法是一个**普通**方法，则它也是一个**普通**方法

    若调用它的方法是一个**事务**方法，，则它会加入调用的方法的事务

  - PROPAGATION_MANDATORY

    `[ˈmændətəri]强制性的`

    如果调用他的方法**不是存在事务**的方法，则会**抛出异常**

- **怎么让一个字段不被数据库存储**

  在实体类字段使用transient、@Transient、static、final修饰

- **SpringBoot启动**

  - spring-boot-starter-`组件`：引入该`组件`**所有的相关**依赖，不用为一个组件特意去引入其他他需要的jar包

    > 之前创建MVC工程需要引入：spring-webmvc、tomcat-servlet-api

  - spring-boot-parent

    - 定义的SpringBoot所有相关jar包的**版本号**
    - 指定了项目的编码格式
    - 指定了使用的jdk版本

- **SpringBoot自动装配原理**

    SpringBoot帮我们创建了相关的**所有配置类**，我们只需在pom引入相应的组件即可

    @SpringBootApplication加载**自动配置注解**@EnableAutoConfiguration，该注解会去加载包含这些**配置类位置**的META/INFO/spring.factorires

- **Mybatis分页插件原理**

  拦截sql语句，把sql语句作为子查询，外面包裹一层selct * from再加上limit的分页约束语句

  ```java
  SELECT * FROM user
  SELECT u.* FROM (SELECT * FROM user) u LIMIT M, N
  ```

- **Mybatis缓存**

  - **Mybatis一级缓存**

    - **SqlSession级别**的缓存，同一个SqlSession对象的才共享缓存

    - 第一次查询到的数据缓存在**本地**，第二次查询从缓存获取，而不访问数据库

      **原理**：缓存使用了一个map数据结构，key为sql+参数，value为行数据

    - **默认开启**一级缓存

  - **Mybatis二级缓存**

    **mapper级别**的缓存，同一个namespace的mapper映射文件对应相同一个缓存

  - **knowledge**

    - **不建议**使用Mybatis缓存
      - 缓存是基于本地的，**分布式**环境下会出现脏读问题
      - 多个mapper文件对同一个进行操作，前一个文件更新了表数据，而后一个文件却还是缓存了**旧数据**，造成数据不一致

    - **@Autowired**一个mapper类，则该service类共享同一个SqlSession对象

      其实是使用SqlSerssion的getMapper()来创建mapper层实例

      UserMapper userMapper=sqlSession.getMapper(UserMapper.class);User user=userMappper.findById();

- **@Retention**

  设置注解保留的地方，也是定义注解被保留的时间长短

  SOURCE < CLASS < RUNTIME

- **Spring MVC的流程**

    - 用户根据**url**请求后端，**前端控制器**DispatcherServlet接受url数据后调用处理器映射器

    - **处理器映射器**对url进行解析，把url所要请求的后端方法，封装返回给前端控制器DispatcherServlet

    - 前端控制器请求**处理器适配器**执行，执行后返回**ModuleAndView**给前端控制器

        处理器设配器应该是Controller层

    - 前端控制器把ModuleAndView返回给**视图解析器**，解析为**View**，返回给前端控制器

        View应该是**JSON格式**的实体类数据

        ModuleAndView应该是实体类数据

    - 前端控制器再把View渲染成**视图**

    - 把视图返回给前端，展示给用户













